# Autogenerated file. Do not edit.
from jacdac.bus import Bus, Client
from .constants import *
from typing import Optional


class TimeseriesAggregatorClient(Client):
    """
    Supports aggregating timeseries data (especially sensor readings)
     * and sending them to a cloud/storage service.
     * Used in Jacscript.
     * 
     * Note that `f64` values following a label are not necessarily aligned.
    Implements a client for the `Timeseries Aggregator <https://microsoft.github.io/jacdac-docs/services/timeseriesaggregator>`_ service.

    """

    def __init__(self, bus: Bus, role: str) -> None:
        super().__init__(bus, JD_SERVICE_CLASS_TIMESERIES_AGGREGATOR, JD_TIMESERIES_AGGREGATOR_PACK_FORMATS, role)


    @property
    def now(self) -> Optional[int]:
        """
        This register is automatically broadcast and can be also queried to establish local time on the device., _: us
        """
        return self.register(JD_TIMESERIES_AGGREGATOR_REG_NOW).value()

    @property
    def fast_start(self) -> Optional[bool]:
        """
        When `true`, the windows will be shorter after service reset and gradually extend to requested length.
        This makes the sensor look more responsive., 
        """
        return self.register(JD_TIMESERIES_AGGREGATOR_REG_FAST_START).bool_value()

    @fast_start.setter
    def fast_start(self, value: bool) -> None:
        self.register(JD_TIMESERIES_AGGREGATOR_REG_FAST_START).set_values(value)


    @property
    def continuous_window(self) -> Optional[int]:
        """
        Window applied to automatically created continuous timeseries.
        Note that windows returned initially may be shorter., _: ms
        """
        return self.register(JD_TIMESERIES_AGGREGATOR_REG_CONTINUOUS_WINDOW).value()

    @continuous_window.setter
    def continuous_window(self, value: int) -> None:
        self.register(JD_TIMESERIES_AGGREGATOR_REG_CONTINUOUS_WINDOW).set_values(value)


    @property
    def discrete_window(self) -> Optional[int]:
        """
        Window applied to automatically created discrete timeseries., _: ms
        """
        return self.register(JD_TIMESERIES_AGGREGATOR_REG_DISCRETE_WINDOW).value()

    @discrete_window.setter
    def discrete_window(self, value: int) -> None:
        self.register(JD_TIMESERIES_AGGREGATOR_REG_DISCRETE_WINDOW).set_values(value)



    def clear(self, ) -> None:
        """
        Remove all pending timeseries.
        """
        self.send_cmd_packed(JD_TIMESERIES_AGGREGATOR_CMD_CLEAR, )

    def start_timeseries(self, id: int, mode: TimeseriesAggregatorDataMode, label: str) -> None:
        """
        Starts a new timeseries.
        As for `mode`,
        `Continuous` has default aggregation window of 60s,
        and `Discrete` only stores the data if it has changed since last store,
        and has default window of 1s.
        """
        self.send_cmd_packed(JD_TIMESERIES_AGGREGATOR_CMD_START_TIMESERIES, id, mode, label)

    def update(self, value: float, id: int) -> None:
        """
        Add a data point to a timeseries.
        """
        self.send_cmd_packed(JD_TIMESERIES_AGGREGATOR_CMD_UPDATE, value, id)

    def set_window(self, id: int, duration: int) -> None:
        """
        Set aggregation window.
        """
        self.send_cmd_packed(JD_TIMESERIES_AGGREGATOR_CMD_SET_WINDOW, id, duration)
    
