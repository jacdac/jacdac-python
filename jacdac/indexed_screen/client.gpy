from jacdac.bus import Bus, Client
from .constants import *
from typing import Union


class IndexedScreenClient(Client):
    """
    A screen with indexed colors.
     * 
     * This is often run over an SPI connection, not regular single-wire JACDAC.
    """

    def __init__(self, bus: Bus, role: str) -> None:
        super().__init__(bus, JD_SERVICE_CLASS_INDEXED_SCREEN, JD_INDEXED_SCREEN_PACK_FORMATS, role)
    

    @property
    def brightness(self) -> Union[float, None]:
        """
        Set backlight brightness.
        If set to `0` the display may go to sleep., /
        """
        reg = self.register(JD_INDEXED_SCREEN_REG_BRIGHTNESS)
        return reg.value(0)

    @brightness.setter
    def brightness(self, value: float) -> None:
        reg = self.register(JD_INDEXED_SCREEN_REG_BRIGHTNESS)
        reg.set_value(0, value)


    @property
    def bits_per_pixel(self) -> Union[float, None]:
        """
        Determines the number of palette entries.
        Typical values are 1, 2, 4, or 8., bit
        """
        reg = self.register(JD_INDEXED_SCREEN_REG_BITS_PER_PIXEL)
        return reg.value(0)

    @property
    def width(self) -> Union[float, None]:
        """
        Screen width in "natural" orientation., px
        """
        reg = self.register(JD_INDEXED_SCREEN_REG_WIDTH)
        return reg.value(0)

    @property
    def height(self) -> Union[float, None]:
        """
        Screen height in "natural" orientation., px
        """
        reg = self.register(JD_INDEXED_SCREEN_REG_HEIGHT)
        return reg.value(0)

    @property
    def width_major(self) -> Union[bool, None]:
        """
        If true, consecutive pixels in the "width" direction are sent next to each other (this is typical for graphics cards).
        If false, consecutive pixels in the "height" direction are sent next to each other.
        For embedded screen controllers, this is typically true iff `width < height`
        (in other words, it's only true for portrait orientation screens).
        Some controllers may allow the user to change this (though the refresh order may not be optimal then).
        This is independent of the `rotation` register.
        """
        reg = self.register(JD_INDEXED_SCREEN_REG_WIDTH_MAJOR)
        return reg.value(0)

    @width_major.setter
    def width_major(self, value: bool) -> None:
        reg = self.register(JD_INDEXED_SCREEN_REG_WIDTH_MAJOR)
        reg.set_value(0, value)


    @property
    def up_sampling(self) -> Union[float, None]:
        """
        Every pixel sent over wire is represented by `up_sampling x up_sampling` square of physical pixels.
        Some displays may allow changing this (which will also result in changes to `width` and `height`).
        Typical values are 1 and 2., px
        """
        reg = self.register(JD_INDEXED_SCREEN_REG_UP_SAMPLING)
        return reg.value(0)

    @up_sampling.setter
    def up_sampling(self, value: float) -> None:
        reg = self.register(JD_INDEXED_SCREEN_REG_UP_SAMPLING)
        reg.set_value(0, value)


    @property
    def rotation(self) -> Union[float, None]:
        """
        Possible values are 0, 90, 180 and 270 only.
        Write to this register do not affect `width` and `height` registers,
        and may be ignored by some screens., Â°
        """
        reg = self.register(JD_INDEXED_SCREEN_REG_ROTATION)
        return reg.value(0)

    @rotation.setter
    def rotation(self, value: float) -> None:
        reg = self.register(JD_INDEXED_SCREEN_REG_ROTATION)
        reg.set_value(0, value)



    def start_update(self, x: float, y: float, width: float, height: float) -> None:
        """
        Sets the update window for subsequent `set_pixels` commands.
        """
        # TODO: self.sendCommand(jacdac.JDPacket.jdpacked(JD_indexed_Screen_CMD_start_update, "u16 u16 u16 u16", [x, y, width, height]))

    def set_pixels(self, pixels: bytes) -> None:
        """
        Set pixels in current window, according to current palette.
        Each "line" of data is aligned to a byte.
        """
        # TODO: self.sendCommand(jacdac.JDPacket.jdpacked(JD_indexed_Screen_CMD_set_pixels, "b", [pixels]))
    
