# Autogenerated file. Do not edit.
from jacdac.bus import Bus, Client
from .constants import *
from typing import Optional, cast


class SoundSpectrumClient(Client):
    """
    A microphone that analyzes the sound specturm
    """

    def __init__(self, bus: Bus, role: str) -> None:
        super().__init__(bus, JD_SERVICE_CLASS_SOUND_SPECTRUM, JD_SOUND_SPECTRUM_PACK_FORMATS, role)
    

    @property
    def frequency_bins(self) -> Optional[bytes]:
        """
        The computed frequency data., 
        """
        reg = self.register(JD_SOUND_SPECTRUM_REG_FREQUENCY_BINS)
        values = reg.values()
        return cast(Optional[bytes], values[0] if values else None)

    @property
    def enabled(self) -> Optional[bool]:
        """
        Turns on/off the micropohone., 
        """
        reg = self.register(JD_SOUND_SPECTRUM_REG_ENABLED)
        values = reg.values()
        return cast(Optional[bool], values[0] if values else None)

    @enabled.setter
    def enabled(self, value: bool) -> None:
        reg = self.register(JD_SOUND_SPECTRUM_REG_ENABLED)
        reg.set_values(value) # type: ignore


    @property
    def fft_pow2_size(self) -> Optional[int]:
        """
        The power of 2 used as the size of the FFT to be used to determine the frequency domain., 
        """
        reg = self.register(JD_SOUND_SPECTRUM_REG_FFT_POW2_SIZE)
        values = reg.values()
        return cast(Optional[int], values[0] if values else None)

    @fft_pow2_size.setter
    def fft_pow2_size(self, value: int) -> None:
        reg = self.register(JD_SOUND_SPECTRUM_REG_FFT_POW2_SIZE)
        reg.set_values(value) # type: ignore


    @property
    def min_decibels(self) -> Optional[int]:
        """
        The minimum power value in the scaling range for the FFT analysis data, _: dB
        """
        reg = self.register(JD_SOUND_SPECTRUM_REG_MIN_DECIBELS)
        values = reg.values()
        return cast(Optional[int], values[0] if values else None)

    @min_decibels.setter
    def min_decibels(self, value: int) -> None:
        reg = self.register(JD_SOUND_SPECTRUM_REG_MIN_DECIBELS)
        reg.set_values(value) # type: ignore


    @property
    def max_decibels(self) -> Optional[int]:
        """
        The maximum power value in the scaling range for the FFT analysis data, _: dB
        """
        reg = self.register(JD_SOUND_SPECTRUM_REG_MAX_DECIBELS)
        values = reg.values()
        return cast(Optional[int], values[0] if values else None)

    @max_decibels.setter
    def max_decibels(self, value: int) -> None:
        reg = self.register(JD_SOUND_SPECTRUM_REG_MAX_DECIBELS)
        reg.set_values(value) # type: ignore


    @property
    def smoothing_time_constant(self) -> Optional[float]:
        """
        The averaging constant with the last analysis frame. 
        If ``0`` is set, there is no averaging done, whereas a value of ``1`` means "overlap the previous and current buffer quite a lot while computing the value"., _: /
        """
        reg = self.register(JD_SOUND_SPECTRUM_REG_SMOOTHING_TIME_CONSTANT)
        values = reg.values()
        return cast(Optional[float], values[0] if values else None)

    @smoothing_time_constant.setter
    def smoothing_time_constant(self, value: float) -> None:
        reg = self.register(JD_SOUND_SPECTRUM_REG_SMOOTHING_TIME_CONSTANT)
        reg.set_values(value) # type: ignore


    
