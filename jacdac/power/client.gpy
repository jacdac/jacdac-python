from jacdac.bus import Bus, Client
from .constants import *
from typing import Union, cast
from jacdac.events import EventHandlerFn, UnsubscribeFn

class PowerClient(Client):
    """
    A power-provider service.
    """

    def __init__(self, bus: Bus, role: str) -> None:
        super().__init__(bus, JD_SERVICE_CLASS_POWER, JD_POWER_PACK_FORMATS, role)
    

    @property
    def allowed(self) -> Union[bool, None]:
        """
        Can be used to completely disable the service.
        When allowed, the service may still not be providing power, see 
        `power_status` for the actual current state.
        """
        reg = self.register(JD_POWER_REG_ALLOWED)
        value = reg.value(0)
        return cast(Union[bool, None], value)

    @allowed.setter
    def allowed(self, value: bool) -> None:
        reg = self.register(JD_POWER_REG_ALLOWED)
        reg.set_value(0, value)


    @property
    def max_power(self) -> Union[int, None]:
        """
        (Optional) Limit the power provided by the service. The actual maximum limit will depend on hardware.
        This field may be read-only in some implementations - you should read it back after setting., mA
        """
        reg = self.register(JD_POWER_REG_MAX_POWER)
        value = reg.value(0)
        return cast(Union[int, None], value)

    @max_power.setter
    def max_power(self, value: int) -> None:
        reg = self.register(JD_POWER_REG_MAX_POWER)
        reg.set_value(0, value)


    @property
    def power_status(self) -> Union[PowerPowerStatus, None]:
        """
        Indicates whether the power provider is currently providing power (`Powering` state), and if not, why not.
        `Overprovision` means there was another power provider, and we stopped not to overprovision the bus.
        """
        reg = self.register(JD_POWER_REG_POWER_STATUS)
        value = reg.value(0)
        return cast(Union[PowerPowerStatus, None], value)

    @property
    def current_draw(self) -> Union[int, None]:
        """
        (Optional) Present current draw from the bus., mA
        """
        reg = self.register(JD_POWER_REG_CURRENT_DRAW)
        value = reg.value(0)
        return cast(Union[int, None], value)

    @property
    def battery_voltage(self) -> Union[int, None]:
        """
        (Optional) Voltage on input., mV
        """
        reg = self.register(JD_POWER_REG_BATTERY_VOLTAGE)
        value = reg.value(0)
        return cast(Union[int, None], value)

    @property
    def battery_charge(self) -> Union[float, None]:
        """
        (Optional) Fraction of charge in the battery., /
        """
        reg = self.register(JD_POWER_REG_BATTERY_CHARGE)
        value = reg.value(0)
        return cast(Union[float, None], value)

    @property
    def battery_capacity(self) -> Union[int, None]:
        """
        (Optional) Energy that can be delivered to the bus when battery is fully charged.
        This excludes conversion overheads if any., mWh
        """
        reg = self.register(JD_POWER_REG_BATTERY_CAPACITY)
        value = reg.value(0)
        return cast(Union[int, None], value)

    @property
    def keep_on_pulse_duration(self) -> Union[int, None]:
        """
        (Optional) Many USB power packs need current to be drawn from time to time to prevent shutdown.
        This regulates how often and for how long such current is drawn.
        Typically a 1/8W 22 ohm resistor is used as load. This limits the duty cycle to 10%., ms
        """
        reg = self.register(JD_POWER_REG_KEEP_ON_PULSE_DURATION)
        value = reg.value(0)
        return cast(Union[int, None], value)

    @keep_on_pulse_duration.setter
    def keep_on_pulse_duration(self, value: int) -> None:
        reg = self.register(JD_POWER_REG_KEEP_ON_PULSE_DURATION)
        reg.set_value(0, value)


    @property
    def keep_on_pulse_period(self) -> Union[int, None]:
        """
        (Optional) Many USB power packs need current to be drawn from time to time to prevent shutdown.
        This regulates how often and for how long such current is drawn.
        Typically a 1/8W 22 ohm resistor is used as load. This limits the duty cycle to 10%., ms
        """
        reg = self.register(JD_POWER_REG_KEEP_ON_PULSE_PERIOD)
        value = reg.value(0)
        return cast(Union[int, None], value)

    @keep_on_pulse_period.setter
    def keep_on_pulse_period(self, value: int) -> None:
        reg = self.register(JD_POWER_REG_KEEP_ON_PULSE_PERIOD)
        reg.set_value(0, value)


    def on_power_status_changed(self, handler: EventHandlerFn) -> UnsubscribeFn:
        """
        Emitted whenever `power_status` changes.
        """
        return self.on_event(JD_POWER_EV_POWER_STATUS_CHANGED, handler)


    def shutdown(self, ) -> None:
        """
        Sent by the power service periodically, as broadcast.
        """
        self.send_cmd_packed(JD_POWER_CMD_SHUTDOWN, )
    
